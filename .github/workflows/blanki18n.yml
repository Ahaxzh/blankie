name: Extract Localization Files to Separate Branch

on:
  push:
    paths:
      - "**/*.xcstrings"
      - ".github/workflows/blanki8n.yml"
      - ".github/scripts/extract-strings.js"
  # Allow manual trigger
  workflow_dispatch:

permissions:
  contents: write

jobs:
  extract:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Install dependencies
        run: npm install glob

      - name: Create extraction script
        run: |
          mkdir -p .github/scripts
          cat > .github/scripts/extract-strings.js << 'EOL'
          #!/usr/bin/env node

          const fs = require('fs');
          const path = require('path');
          const glob = require('glob');

          // Parse args
          const args = process.argv.slice(2);
          let globPattern = "**/*.xcstrings";
          let outputDir = "tmp";

          for (let i = 0; i < args.length; i += 2) {
            if (args[i] === '--globs') globPattern = args[i + 1];
            if (args[i] === '--output-dir') outputDir = args[i + 1];
          }

          console.log(`Looking for files matching: ${globPattern}`);

          try {
            // Find all matching files
            const files = glob.sync(globPattern);
            
            if (files.length === 0) {
              console.error(`No files found matching: ${globPattern}`);
              process.exit(1);
            }
            
            console.log(`Found ${files.length} file(s)`);
            
            // Initialize result object
            const result = {
              metadata: {
                extractedAt: new Date().toISOString(),
                tool: "blanki8n-action",
                files: files
              },
              strings: {}
            };
            
            // Process each file
            files.forEach(file => {
              console.log(`Processing ${file}`);
              try {
                const content = fs.readFileSync(file, 'utf8');
                const json = JSON.parse(content);
                
                // Extract strings and their metadata
                if (json.strings) {
                  Object.keys(json.strings).forEach(key => {
                    // Initialize key in result if it doesn't exist
                    if (!result.strings[key]) {
                      result.strings[key] = {};
                    }

                    // Extract comment if available
                    if (json.strings[key].comment) {
                      result.strings[key].comment = json.strings[key].comment;
                    }
                    
                    // Extract English strings if available (source language)
                    if (json.strings[key].localizations?.en?.stringUnit?.value) {
                      result.strings[key].en = {
                        value: json.strings[key].localizations.en.stringUnit.value,
                        state: json.strings[key].localizations.en.stringUnit.state || "translated"
                      };
                    }
                    
                    // Extract other locales if available
                    if (json.strings[key].localizations) {
                      Object.keys(json.strings[key].localizations).forEach(locale => {
                        if (locale !== 'en' && json.strings[key].localizations[locale]?.stringUnit?.value) {
                          result.strings[key][locale] = {
                            value: json.strings[key].localizations[locale].stringUnit.value,
                            state: json.strings[key].localizations[locale].stringUnit.state || "translated"
                          };
                        }
                      });
                    }
                  });
                }
              } catch (error) {
                console.error(`Error processing ${file}: ${error.message}`);
              }
            });
            
            // Create output directory if it doesn't exist
            if (!fs.existsSync(outputDir)) {
              fs.mkdirSync(outputDir, { recursive: true });
            }
            
            // Save the complete extraction result
            fs.writeFileSync(path.join(outputDir, 'extracted.json'), JSON.stringify(result, null, 2));
            console.log(`Extraction complete. Full data saved to ${path.join(outputDir, 'extracted.json')}`);
            
            // Find all languages in the data
            const languages = new Set(['en']);
            Object.keys(result.strings).forEach(key => {
              Object.keys(result.strings[key]).forEach(lang => {
                if (lang !== 'comment' && lang !== 'context') {
                  languages.add(lang);
                }
              });
            });
            
            console.log(`Found ${languages.size} languages: ${Array.from(languages).join(', ')}`);
            
            // Create per-language files
            languages.forEach(lang => {
              if (lang === 'en') return; // Skip English as it's the source language
              
              const langData = {
                metadata: {
                  language: lang,
                  extractedAt: result.metadata.extractedAt,
                  sourceFiles: result.metadata.files
                },
                statistics: {
                  totalStrings: 0,
                  translatedStrings: 0,
                  translationPercentage: 0
                },
                strings: {}
              };
              
              let totalStrings = 0;
              let translatedStrings = 0;
              
              // Format each string for this language
              Object.keys(result.strings).forEach(key => {
                // Only count strings that have an English source
                if (result.strings[key].en) {
                  totalStrings++;
                  
                  if (result.strings[key][lang]) {
                    langData.strings[key] = {
                      source: result.strings[key].en.value,
                      target: result.strings[key][lang].value,
                      state: result.strings[key][lang].state || 'translated',
                      comment: result.strings[key].comment || ''
                    };
                    
                    // Count translated strings
                    if (result.strings[key][lang].state === 'translated' || 
                        !result.strings[key][lang].state) { // Default state is translated
                      translatedStrings++;
                    }
                  } else {
                    // Include untranslated strings with empty target
                    langData.strings[key] = {
                      source: result.strings[key].en.value,
                      target: '',
                      state: 'needs_translation',
                      comment: result.strings[key].comment || ''
                    };
                  }
                }
              });
              
              // Calculate translation percentage
              const translationPercentage = totalStrings > 0 
                ? Math.round((translatedStrings / totalStrings) * 100) 
                : 0;
              
              // Update statistics
              langData.statistics.totalStrings = totalStrings;
              langData.statistics.translatedStrings = translatedStrings;
              langData.statistics.translationPercentage = translationPercentage;
              
              // Save language-specific file
              const langFileName = `${lang}.json`;
              fs.writeFileSync(path.join(outputDir, langFileName), JSON.stringify(langData, null, 2));
              console.log(`Created language file: ${path.join(outputDir, langFileName)} (${translationPercentage}% translated)`);
            });
            
            // Create a language index file with translation statistics
            const langIndex = {
              metadata: {
                extractedAt: result.metadata.extractedAt,
                languages: Array.from(languages)
              },
              statistics: {}
            };
            
            // Calculate statistics for each language
            languages.forEach(lang => {
              if (lang === 'en') return; // Skip English as it's the source language
              
              let totalStrings = 0;
              let translatedStrings = 0;
              
              Object.keys(result.strings).forEach(key => {
                if (result.strings[key].en) {
                  totalStrings++;
                  
                  if (result.strings[key][lang] && 
                      (result.strings[key][lang].state === 'translated' || !result.strings[key][lang].state)) {
                    translatedStrings++;
                  }
                }
              });
              
              const translationPercentage = totalStrings > 0 
                ? Math.round((translatedStrings / totalStrings) * 100) 
                : 0;
              
              langIndex.statistics[lang] = {
                totalStrings: totalStrings,
                translatedStrings: translatedStrings,
                translationPercentage: translationPercentage
              };
            });
            
            fs.writeFileSync(path.join(outputDir, 'languages.json'), JSON.stringify(langIndex, null, 2));
            console.log(`Created language index: ${path.join(outputDir, 'languages.json')}`);
            
            // Print translation summary
            console.log('\nTranslation Progress Summary:');
            console.log('============================');
            Object.keys(langIndex.statistics).sort().forEach(lang => {
              const stats = langIndex.statistics[lang];
              console.log(`${lang}: ${stats.translationPercentage}% (${stats.translatedStrings}/${stats.totalStrings})`);
            });
            console.log('============================');
          } catch (error) {
            console.error(`Error during extraction: ${error.message}`);
            process.exit(1);
          }
          EOL

          chmod +x .github/scripts/extract-strings.js

      - name: Run extraction
        run: |
          mkdir -p i18n
          node .github/scripts/extract-strings.js --globs "Blankie/*.xcstrings" --output-dir "i18n"

          echo "--- Extraction Results ---"
          echo "Generated files:"
          ls -la i18n/
          echo "------------------------"

      - name: Deploy to i18n branch
        run: |
          # Configure git
          git config user.name "GitHub Actions Bot"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Create and checkout an orphan branch (no history)
          git checkout --orphan i18n-data

          # Remove everything
          git rm -rf .

          # Move only the specific JSON files to the root 
          # (excluding extracted.json, package.json, and package-lock.json)
          mkdir -p temp
          find i18n -name "*.json" \
            -not -name "extracted.json" \
            -not -name "package.json" \
            -not -name "package-lock.json" \
            -exec cp {} temp/ \;

          # Create a README
          echo "# Blankie Localization Files" > temp/README.md
          echo "" >> temp/README.md
          echo "This branch contains the localization JSON files for Blankie app. These files are automatically generated from .xcstrings files." >> temp/README.md
          echo "" >> temp/README.md
          echo "Last updated: $(date)" >> temp/README.md

          # Add translation statistics to README if summary.txt exists
          if [ -f i18n/summary.txt ]; then
            echo "" >> temp/README.md
            echo "## Translation Status" >> temp/README.md
            echo "" >> temp/README.md
            cat i18n/summary.txt >> temp/README.md
          fi

          # Move the files from temp to root
          mv temp/* .
          rmdir temp

          # Stage only the JSON files and README
          git add *.json README.md

          # Commit with the summary message if it exists
          if [ -f i18n/summary.txt ]; then
            git commit -m "$(cat i18n/summary.txt)"
          else
            git commit -m "Update localization data [skip ci]"
          fi

          # Force push to the i18n-data branch
          git push -f origin i18n-data

          echo "Localization files pushed to i18n-data branch"
